import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from iminuit import Minuit, cost
from tqdm import tqdm
import re

GCD = 15 # decisecodns

class Boss:
    def __init__(self, Stats):
        self.Armor = 3700
        self.Level = 63
        self.SpellResistance = 0
        self.GlancingBlowChance = 0

        if Stats["Armor"] is not None: self.Armor = Stats["Armor"]
        if Stats["Level"] is not None: self.Level = Stats["Level"]
        if Stats["Resistance"] is not None: self.SpellResistance = Stats["Resistance"]

        self.DefenseSkill = 300 + (self.Level - 60) * 5
        self.PhysReduc =  self.Armor / ( self.Armor + 400 + 85 * self.Level)
        self.Dodge = 5 + (self.DefenseSkill - 300) * 0.2
        self.Miss  = 5 + (self.DefenseSkill - 300) * 0.2

        match(self.Level):
            case(60):
                self.SpellMiss = 4
            case(61):
                self.SpellMiss = 5
            case(62):
                self.SpellMiss = 6
            case(63):
                self.SpellMiss = 17
                self.GlancingBlowChance = 40

class Character:
    
    def __init__(self, Target, Stats, Weapon, Talents, SetBonuses):
        # Set default values
        self.BaseWepMin, self.BaseWepMax = 1, 2
        self.WepAttackSpeed = 0
        self.AttackPower    = 0
        self.WeaponSkill    = 0
        self.HitChance      = 0
        self.SpellHitChance = 0
        self.MeleeCrit      = 0
        self.SpellCrit      = 0
        self.Haste          = 0
        
        self.initialize_stats(Stats)
        self.initialize_weapon(Weapon)
        self.initialize_talents(Talents)
        
        # Initialize dynamic variables
        self.WepDamage = (np.array([self.BaseWepMin,self.BaseWepMax]) + (self.AttackPower/14) * (self.WepAttackSpeed/10) ) * 1.1 # 10% increase from talents
        self.AttackSpeed = self.WepAttackSpeed 

        # Update combat stats against target 
        self.MissChance = Target.Miss - (self.HitChance + self.WeaponSkill * 0.2 + 3)
        self.DodgeChance = Target.Dodge 
        self.SpellMissChance = Target.SpellMiss - self.SpellHitChance
        self.SpellResistChance = Target.SpellResistance
        self.GlancingBlowDMG = 0.70 + self.WeaponSkill*0.2
        self.GlancingBlowChance = Target.GlancingBlowChance
        self.ReducedPhysDmg = (1 - Target.PhysReduc)

        self.CharacterBuffs = self.Buffs(self)
        self.CharacterAttacks = self.Attacks(self)

        self.UpdateStats()

    class Buffs:
        def __init__(self, CharacterInput):
            self.CharacterInstance = CharacterInput

            self.Flurry = False
            self.StormStrikeBuff = False
            self.ElementalStrength = False
            self.RapidSpeed = False
            self.ElementalDevastation = False
            self.UnholyStrength = False

            self.FlurryStacks = 3
            self.StormStrikeStacks = 2

            self.ElementalStrengthDuration = 100
            self.RapidSpeedDuration = 80
            self.ElementalDevastationDuration = 100
            self.UnholyStrengthDuration = 150

            self.BuffUptimes = {"Flurry" : 0, "StormStrike" : 0, "ElementalStrength" : 0, "RapidSpeed" : 0, "ElementalDevastation" : 0, "UnholyStrength" : 0}

        def checkBuffs(self):
            if self.Flurry: self.checkFlurry()
            if self.StormStrikeBuff: self.checkStormStrikeBuff()  
            if self.ElementalStrength: self.checkElementalStrength()
            if self.RapidSpeed: self.checkRapidSpeed()  
            if self.ElementalDevastation: self.checkElementalDevastation()
            if self.UnholyStrength: self.checkUnholyStrength()
        
        def checkFlurry(self):
            if self.FlurryStacks == 0:
                self.Flurry = False
                self.CharacterInstance.Haste -= 20
            else: self.BuffUptimes["Flurry"] += 1

        def checkStormStrikeBuff(self):
            if self.StormStrikeStacks == 0:
                self.StormStrikeBuff = False
            else: self.BuffUptimes["StormStrike"] += 1

        def checkElementalStrength(self):
            if self.ElementalStrengthDuration == 0:
                self.ElementalStrength = False
                self.CharacterInstance.AttackPower -= 130
            else:
                self.ElementalStrengthDuration -= 1
                self.BuffUptimes["ElementalStrength"] += 1
        
        def checkRapidSpeed(self):
            if self.RapidSpeedDuration == 0:
                self.RapidSpeed = False
                self.CharacterInstance.Haste -= 8
            else:
                self.RapidSpeedDuration -= 1
                self.BuffUptimes["RapidSpeed"] += 1
        
        def checkElementalDevastation(self):
            if self.ElementalDevastationDuration == 0:
                self.ElementalDevistation = False
                self.CharacterInstance.SpellHitChance -= 9
            else:
                self.ElementalDevastationDuration -= 1
                self.BuffUptimes["ElementalDevastation"] += 1
               
        def checkUnholyStrength(self):
            if self.UnholyStrengthDuration == 0:
                self.UnholyStrength = False
                self.CharacterInstance.AttackPower -= (100*1.05)*2 
            else:
                self.UnholyStrengthDuration -= 1
                self.BuffUptimes["UnholyStrength"] += 1
        
        def procFlurry(self):
            if self.Flurry: 
                self.FlurryStacks = 3
            else:   
                self.Flurry = True
                self.FlurryStacks = 3
                self.CharacterInstance.Haste += 20

        def procStormStrikeBuff(self):
            if self.StormStrikeBuff: 
                self.StormStrikeStacks = 2
            else:   
                self.StormStrikeBuff = True
                self.StormStrikeStacks = 2
        
        def procElementalStrength(self):
            if self.CharacterInstance.DiceRoll() <= 35:
                if self.ElementalStrength:
                    self.ElementalStrengthDuration = 100
                else:
                    self.ElementalStrength = True
                    self.ElementalStrengthDuration = 100
                    self.CharacterInstance.AttackPower += 130
        
        def procRapidSpeed(self):
            if self.CharacterInstance.DiceRoll() <= 15:
                if self.RapidSpeed:
                    self.RapidSpeedDuration = 80
                else:
                    self.RapidSpeed = True
                    self.RapidSpeedDuration = 80
                    self.CharacterInstance.Haste += 8
        
        def procElementalDevastation(self):
            if self.ElementalDevastation:
                self.ElementalDevastationDuration = 100
            else:
                self.ElementalDevastation = True
                self.ElementalDevastationDuration = 100
                self.CharacterInstance.SpellHitChance += 9
            
        def procUnholyStrength(self):
            if self.CharacterInstance.DiceRoll() <= (self.CharacterInstance.WepAttackSpeed/10)*1.82:
                if self.UnholyStrength:
                    self.UnholyStrengthDuration = 150
                else:
                    self.UnholyStrength = True
                    self.UnholyStrengthDuration = 150
                    self.CharacterInstance.AttackPower += (100*1.05)*2

    class Talents:
        def __init__(self, CharacterInput):
            self.CharacterInstance = CharacterInput
            # ELEMENTAL 
            self.Conussion = False
            self.Reverberation = False
            # ENHANCEMENT
            self.WeaponMastery = False

            # RESTORATION ?

    class ItemsAndEnchants:
        def __init__(self, CharacterInput):
            self.CharacterInstance = CharacterInput

    class Attacks:

        def __init__(self, CharacterInput):
            self.CharacterInstance = CharacterInput
            self.SwingTimer = 0
            self.AutoAttackStats = {"Glancing Blow": 0, "Miss" : 0, "Dodge" : 0, "Crit" : 0}
            self.DamageCount = {"Auto Attack" : 0, "Earth Shock" : 0, "Stormstrike" : 0, "Lightning Strike" : 0, "Lightning Shield" : 0}
            self.Cooldowns = {"Earth Shock" : 0, "Stormstrike" : 0, "Lightning Strike" : 0}

        def WeaponSwing(self):
            WepDmg = np.random.randint(self.CharacterInstance.WepDamage[0],self.CharacterInstance.WepDamage[1])
            return WepDmg
        
        def CriticalStrike(self, Damage, Type="Melee"):
            match Type:
                case "Melee":
                    if self.CharacterInstance.DiceRoll() <= self.CharacterInstance.MeleeCrit:
                        Damage *= 2.0
                        self.CharacterInstance.CharacterBuffs.procFlurry()
                        self.CharacterInstance.CharacterBuffs.procElementalDevastation()
                        self.AutoAttackStats["Crit"] += 1
                case "Spell":
                    if self.CharacterInstance.DiceRoll() <= self.CharacterInstance.SpellCrit:
                        Damage *= 1.5
            return Damage

        def EvaluateWhiteAttack(self,Damage):
            if self.CharacterInstance.DiceRoll() <= self.CharacterInstance.DodgeChance:
                Damage = 0
                self.AutoAttackStats["Dodge"] += 1
            elif self.CharacterInstance.DiceRoll() <= (self.CharacterInstance.MissChance):
                Damage = 0 
                self.AutoAttackStats["Miss"] += 1
            else: 
                self.CharacterInstance.CharacterBuffs.procUnholyStrength()
                if self.CharacterInstance.DiceRoll() >= self.CharacterInstance.GlancingBlowChance:
                    Damage *= self.CharacterInstance.GlancingBlowDMG
                    self.AutoAttackStats["Glancing Blow"] += 1
                else: 
                    Damage = self.CriticalStrike(Damage) 
            return Damage * self.CharacterInstance.ReducedPhysDmg
            
        def EvaluateYellowAttack(self,Damage):
            if self.CharacterInstance.DiceRoll() <= self.CharacterInstance.DodgeChance:
                Damage = 0
            elif self.CharacterInstance.DiceRoll() <= (self.CharacterInstance.MissChance ):
                Damage = 0
            else: 
                self.CharacterInstance.CharacterBuffs.procUnholyStrength()
                Damage = self.CriticalStrike(Damage) 
                self.Windfury()
            return Damage * self.CharacterInstance.ReducedPhysDmg
            
        def EvaluateSpellAttack(self,Damage):
            if self.CharacterInstance.DiceRoll() <= (self.CharacterInstance.SpellMissChance):
                Damage = 0
            elif self.CharacterInstance.DiceRoll() <= self.CharacterInstance.SpellResistChance:
                Damage = 0
            else: 
                Damage = self.CriticalStrike(Damage,"Spell")
            return Damage
        
        def AutoAttack(self):
            if self.CharacterInstance.CharacterBuffs.Flurry: self.CharacterInstance.CharacterBuffs.FlurryStacks -= 1
            Damage = self.EvaluateWhiteAttack(self.WeaponSwing())
            if Damage != 0: self.Windfury()
            self.DamageCount["Auto Attack"] += Damage
            self.SwingTimer = 0
            return Damage
        
        def Windfury(self):
            WF_PROC = 20 # %
            Damage = 0
            if self.CharacterInstance.DiceRoll() <= WF_PROC:
                self.CharacterInstance.AttackPower += 323
                self.CharacterInstance.UpdateStats()
                Damage += self.EvaluateWhiteAttack(self.WeaponSwing())
                Damage += self.EvaluateWhiteAttack(self.WeaponSwing())
                self.CharacterInstance.AttackPower -= 323
                self.CharacterInstance.UpdateStats()
            self.DamageCount["Auto Attack"] += Damage
            return Damage
            
        def EarthShock(self):
            DmgAmp = 1.0
            if self.CharacterInstance.CharacterBuffs.StormStrikeBuff:
                DmgAmp = 1.20
                self.CharacterInstance.CharacterBuffs.StormStrikeStacks -= 1
            Damage = (np.random.randint(517,546) + (0.10 * self.CharacterInstance.AttackPower)) * DmgAmp
            self.Cooldowns["Earth Shock"] = 50 
            self.CharacterInstance.CharacterBuffs.procElementalStrength()
            Damage = self.EvaluateSpellAttack(Damage)
            self.DamageCount["Earth Shock"] += Damage
            return Damage
        
        def StormStrike(self):
            AttackCoef = 1.11
            self.CharacterInstance.CharacterBuffs.procStormStrikeBuff()
            Damage = self.EvaluateYellowAttack(AttackCoef*self.WeaponSwing())
            self.Cooldowns["Stormstrike"] = 75
            self.DamageCount["Stormstrike"] += Damage
            return Damage
        
        def LightningStrike(self):
            AttackCoef = 0.88
            self.CharacterInstance.CharacterBuffs.procRapidSpeed()
            self.PopLightningShield()
            Damage = self.EvaluateYellowAttack(AttackCoef*self.WeaponSwing())
            self.Cooldowns["Lightning Strike"] = 85
            self.DamageCount["Lightning Strike"] += Damage 
            return Damage
        
        def PopLightningShield(self):
            DmgAmp = 1.0
            if self.CharacterInstance.CharacterBuffs.StormStrikeBuff:
                DmgAmp = 1.20
                self.CharacterInstance.CharacterBuffs.StormStrikeStacks -= 1
            Damage = (198 + self.CharacterInstance.AttackPower/4) * DmgAmp
            Damage = self.EvaluateSpellAttack(Damage)
            self.DamageCount["Lightning Shield"] += Damage
            return Damage

    def DiceRoll(self):
        return np.random.randint(1,101)
    
    def initialize_stats(self, Stats):
        if Stats["AttackPower"] is not None: self.AttackPower = Stats["AttackPower"]
        if Stats["Haste"] is not None: self.Haste = Stats["Haste"]
        if Stats["MeleeHit"] is not None: self.HitChance = Stats["MeleeHit"]
        if Stats["MeleeCrit"] is not None: self.MeleeCrit = Stats["MeleeCrit"]
        if Stats["SpellHit"] is not None: self.SpellHit = Stats["SpellHit"]
        if Stats["SpellCrit"] is not None: self.SpellCrit = Stats["SpellCrit"]

    def initialize_weapon(self, Weapon):
        if Weapon["WeaponDmg"] is not None: self.BaseWepMin, self.BaseWepMax = Weapon["WeaponDmg"][0], Weapon["WeaponDmg"][1]
        if Weapon["WepSpeed"] is not None: self.WepAttackSpeed = Weapon["WepSpeed"] * 10
        if Weapon["WeaponSkill"] is not None: self.WeaponSkill = Weapon["WeaponSkill"]

    def initialize_talents(self, Talents):
        return
        
    def UpdateStats(self):
        self.WepDamage = (np.array([self.BaseWepMin,self.BaseWepMax]) + (self.AttackPower/14) * (self.WepAttackSpeed/10) )*1.1 # 10% increase from talents
        self.AttackSpeed = self.WepAttackSpeed * (1 - self.Haste/100) 
    
def simulate(inputs):
    Target = Boss(inputs["TargetStats"])
    Dolph = Character(Target, inputs["Stats"],inputs["Weapon"],inputs["Talents"],inputs["SetBonuses"])
    SS_Count, ES_Count, LS_Count = 0, 0, 0
    GlobalCooldown = 0
    SimTime = inputs["Sim"]["Time"]
    SimTime_Deciseconds = SimTime*10
    
    for t in range(SimTime_Deciseconds):
        
        Dolph.CharacterBuffs.checkBuffs()
        Dolph.UpdateStats()
        
        if Dolph.CharacterAttacks.SwingTimer >= Dolph.AttackSpeed:
            Dolph.CharacterAttacks.AutoAttack()
            
        if (Dolph.CharacterAttacks.Cooldowns["Stormstrike"] == 0 and GlobalCooldown == 0):
            Dolph.CharacterAttacks.StormStrike()
            SS_Count += 1
            GlobalCooldown = GCD
            
        if (Dolph.CharacterAttacks.Cooldowns["Earth Shock"] == 0 and GlobalCooldown == 0):
            Dolph.CharacterAttacks.EarthShock()
            ES_Count += 1
            GlobalCooldown = GCD
            
        if (Dolph.CharacterAttacks.Cooldowns["Lightning Strike"] == 0 and GlobalCooldown == 0):
            Dolph.CharacterAttacks.LightningStrike()
            LS_Count += 1
            GlobalCooldown = GCD
            
        Dolph.CharacterAttacks.SwingTimer += 1
        
        if Dolph.CharacterAttacks.Cooldowns["Stormstrike"] > 0: Dolph.CharacterAttacks.Cooldowns["Stormstrike"] -= 1
        if Dolph.CharacterAttacks.Cooldowns["Earth Shock"] > 0: Dolph.CharacterAttacks.Cooldowns["Earth Shock"] -= 1
        if Dolph.CharacterAttacks.Cooldowns["Lightning Strike"]> 0: Dolph.CharacterAttacks.Cooldowns["Lightning Strike"]-= 1
        
        if GlobalCooldown > 0: GlobalCooldown -= 1

    TotalDPS = 0
    for key in Dolph.CharacterAttacks.DamageCount.keys():
        Dolph.CharacterAttacks.DamageCount[key] /= SimTime_Deciseconds/10
        TotalDPS += Dolph.CharacterAttacks.DamageCount[key]
    
    return TotalDPS, Dolph.CharacterAttacks.DamageCount, Dolph.CharacterAttacks.AutoAttackStats, Dolph.CharacterBuffs.BuffUptimes

def Gaussian(x,N,mu,sigma):
    return N * 1.0 / (np.sqrt(2*np.pi) * sigma) * np.exp( -0.5 * (x-mu)**2 / sigma**2)


def read_input(file):
    sections = {}
    current_section = None
    with open(file, 'r') as file:
        for line in file:
            line = line.strip()
            if re.match(r'^@\w+', line):
                current_section = line[1:].strip()
                sections[current_section] = {}
            elif line == '@':
                current_section = None  # End of a section
            elif current_section:
                match = re.match(r'^(.*?):\s*(.*)$', line)
                if match:
                    key, value = match.groups()
                    key = key.strip()
                    value = value.strip()
                    if "-" in value:
                        value = [int(x) for x in value.split("-")]
                    # Convert value to int or float if possible
                    elif re.match(r'^\d+$', value):
                        value = int(value)
                    elif re.match(r'^\d+\.\d+$', value):
                        value = float(value)
                    
                    sections[current_section][key] = value if value else None
    
    return sections



def main():
    inputs = read_input(sys.argv[1])
    print(inputs)
    NumSims = inputs["Sim"]["NumberSims"]
    SimTime = inputs["Sim"]["Time"]
    nbins = 30
    sim_DPS   = np.zeros(NumSims)
    sim_Crits = np.zeros(NumSims)
    ES_DMG, SS_DMG, LS_DMG, Shield_DMG, AA_DMG, TOT_DMG = np.zeros(NumSims), np.zeros(NumSims), np.zeros(NumSims), np.zeros(NumSims), np.zeros(NumSims), np.zeros(NumSims)
    for sim in tqdm(range(NumSims)):
        
        TotalDPS, DamageCounts, AA_Diag, BuffUptimes = simulate(inputs)
        sim_DPS[sim] = TotalDPS
        sim_Crits[sim] = AA_Diag["Crit"]
        TOT_DMG[sim], AA_DMG[sim] = TotalDPS, DamageCounts["Auto Attack"]
        ES_DMG[sim], SS_DMG[sim] = DamageCounts["Earth Shock"], DamageCounts["Stormstrike"]
        LS_DMG[sim], Shield_DMG[sim] = DamageCounts["Lightning Strike"], DamageCounts["Lightning Shield"]
    
    counts, bin_edges = np.histogram(sim_DPS,bins=nbins)
    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
    bin_centers = bin_centers[counts > 0]
    counts = counts[counts > 0]
    c = cost.LeastSquares(bin_centers,counts,np.sqrt(counts),Gaussian)
    fit = Minuit(c,N=100,mu=np.mean(sim_DPS),sigma=np.std(sim_DPS,ddof=1))
    fit.migrad()
    
    xaxis = np.linspace(min(sim_DPS),max(sim_DPS),1000)
    divided_values = {key: value / (SimTime*10) for key, value in BuffUptimes.items()}

    print(divided_values)
    fig, ax = plt.subplots()
    ax.plot(xaxis,Gaussian(xaxis,*fit.values),color="magenta")
    ax.hist(sim_DPS,bins=nbins,color="darkturquoise",edgecolor="black")
    ax.set_xlabel("DPS"   ,fontsize=15)
    ax.set_ylabel("Counts",fontsize=15)
    mean, std = fit.values["mu"], fit.values["sigma"]
    plotinfo = [r"$\mu$ = " f"{mean:.0f}",
                r"$\sigma$ = " + f"{std:.0f}" ,
                r"$\chi^2 / N_{dof}$ = " + f"{fit.fval:.2f} / {fit.ndof}",
                f"p-value: {stats.chi2.sf(fit.fval,fit.ndof):.2f}"]
                
    ax.text(0.6,0.7,"\n".join(plotinfo),transform=ax.transAxes,fontsize=11)
    plt.tight_layout()
    plt.savefig("Gaussian_DPS.png")
    
    fig, ax = plt.subplots()
    Sources = np.array(["Auto Attack", "Earth Shock", "Stormstrike", "Lightning Strike", "Lightning Shield"])
    Colors = ["grey","yellow","dodgerblue","darkblue","darkturquoise"]
    DamageDist = np.array([AA_DMG.mean(), ES_DMG.mean(), SS_DMG.mean(), LS_DMG.mean(), Shield_DMG.mean()])
    ax.bar(Sources, DamageDist,color=Colors)
    ax.set_xticklabels(ax.get_xticklabels(), rotation=45)
    plt.tight_layout()
    plt.savefig("DPS_Dist.png")
    
if __name__ == "__main__":
    main()